import m from 'mithril'
import {
  createStore,
  applyMiddleware,
  combineReducers,
  bindActionCreators,
  compose,
} from 'redux'
import {
  cloneDeep,
} from 'lodash'

/**
 * @namespace midux
 */

/**
 * @param {Store} store
 * @returns {Function} connect
 * @desc Get a connect function for creating redux containers
 */
export const connectStore = (store) =>
  (mapStateToProps, mapDispatchToProps = {}) =>
    (Component) => {

      //console.log("  midux.factory", Component)

      return {
        // Called before the DOM node is created
        oninit (vnode) {
          let componentOnInit,
            self = this
          // assign Component to context to support 
          // component object property/method instance attachment
          // http://mithril.js.org/components.html#at-initialization
          this.componentCtx = Object.assign({}, cloneDeep(Component))
          this.attrs = {}

          if ("function" === typeof Component )
            this.component = new Component()
          else if ("object" === typeof Component)
            this.component = Component
          else
            throw new Error("midux.connect required a component object, function, or class")


          //console.log("  midux.oninit", this.component)

          if ("function" == typeof this.component.oninit)
            this.component.oninit.call(this.componentCtx, copyVnode(vnode, this.componentCtx))
          this.unsubscribe = store.subscribe(() => {
            self.attrs = getComponentAttrs()
          })
          this.attrs = getComponentAttrs()

        },



        // Called after the DOM node is created
        oncreate (vnode) {
          if (this.component && "function" == typeof this.component.oncreate)
            this.component.oncreate.call(this.componentCtx, copyVnode(vnode, this.componentCtx))
        },
        // Called before the node is updated, return false to cancel
        onbeforeupdate (vnode, old) {
          if (this.component && "function" == typeof this.component.onbeforeupdate)
            return this.component.onbeforeupdate.call(this.componentCtx, copyVnode(vnode, this.componentCtx), copyVnode(old, this.componentCtx))
          return true
        },
        // Called after the node is updated
        onupdate (vnode) {
          if (this.component && "function" == typeof this.component.onupdate)
            this.component.onupdate.call(this.componentCtx, copyVnode(vnode, this.componentCtx))
        },
        // Called before the node is removed, return a Promise that resolves when
        // ready for the node to be removed from the DOM
        onbeforeremove (vnode) {
          if (this.component && "function" == typeof this.component.onbeforeremove)
            return this.component.onbeforeremove.call(this.componentCtx, copyVnode(vnode, this.componentCtx))

          return new Promise((resolve, reject) => {
            resolve();
          });
        },




        // Called before the node is removed, but after onbeforeremove calls done()
        onremove (vnode) {

          //console.log("  midux.onremove", this.component)
          if (this.unsubscribe)
            this.unsubscribe()
          this.unsubscribe = null
          this.attrs = {}
          if ("function" == typeof this.component.onremove)
            this.component.onremove.call(this.componentCtx, copyVnode(vnode, this.componentCtx))

        },

        view (vnode) {

          //console.log(" midux.view", this.component)
          return this.component.view.call(this.componentCtx, copyVnode(vnode, this.componentCtx))

        }

    }

    function copyVnode(vnode, componentCtx) {
      return Object.assign(
          {},
          vnode,
          {
            state: {...componentCtx},
            attrs: getComponentAttrs(),
          }
      )
    }

    function getComponentAttrs () {
      return Object.assign(
        {},
        mapStateToProps(store.getState(), {}),
        {actions: bindActionCreators(mapDispatchToProps, store.dispatch)}
      )
    }
}

export const safeRedraw = () => {
  setTimeout(() => {
    m.redraw();
  }, 500)
}

/**
 * @param {Array.<Reducer>} reducers
 * @param {Array.<Middleware>} [middleware=[]]
 * @param {Object} [initialState={}]
 * @returns {Store}
 * @desc Configure store to use reducers/middleware
 */
export const configureStore = (reducers, middleware = [], initialState = {}) => {

  return createStore(
    combineReducers(reducers),
    initialState,
    compose(applyMiddleware(...middleware))
  )
}
